export type BlinkTradeParams = {
  url?: string;
  prod?: boolean;
  brokerId?: number;
  transport?: any;
  level?: BlinkTradeLevel;
};

export type BlinkTradeLevel = 0 | 2;
export type BlinkTradeCurrencies = | 'USD' | 'BRL' | 'CLP' | 'VND';

export type BlinkTradeRestTransport = {
  fetchPublic: (string) => Promise<AnyObject>;
  fetchTrade: (msg: Message) => Promise<AnyObject>;
};

export type BlinkTradeRestParams = {
  key?: string;
  secret?: string;
  currency?: BlinkTradeCurrencies;
  transport?: BlinkTradeRestTransport;
} & BlinkTradeParams;

export type BlinkTradeWSTransport = {
  connect: (callback?: Function) => Promise<AnyObject>;
  disconnect: () => void;
  sendMessage: (msg: Message) => void;
  sendMessageAsPromise: (msg: Message) => Promise<AnyObject>;
  emitterPromise?: (promise: any, callback?: Function) => PromiseEmitter<AnyObject>;
  eventEmitter: any;
};

export type BlinkTradeWSParams = {
  headers?: AnyObject;
  fingerPrint?: string;
  reconnect?: boolean;
  reconnectInterval?: number;
  transport?: BlinkTradeWSTransport;
} & BlinkTradeParams;

export type MarketDataParams = Array<string> | {
  instruments: Array<string>;
  columns?: Array<string>;
  entryTypes?: Array<0 | 1 | 2>;
  marketDepth?: number;
  level?: BlinkTradeLevel;
};

export type Message = {
  MsgType: string;
} & AnyObject;

export type AnyObject = {
  [key: string]: any;
};

export type StatusListType = '1' | '2' | '4' | '8';
export type OrderSide = 'BUY' | 'SELL' | '1' | '2';
export type OrderType = 'MARKET' | 'LIMIT' | 'STOP' | 'STOP_LIMIT';

export type Pagination = {
  page?: number;
  pageSize?: number;
};

export type DepositWithdrawList = {
  /**
    * [ADMIN] Optional id of a customer
    */
  clientId?: string,


  /**
    * Array of filters
    */
  filter?: Array<string>,
  /**
    * 1-Pending, 2-In Progress, 4-Completed, 8-Cancelled
    */
  status?: Array<StatusListType>,
} & Pagination

export class BlinkTradeTrade {
  constructor(props: BlinkTradeParams);

  /**
   * Request balance.
   *
   * @Events: `BALANCE`
   */
  balance(clientId?: number, callback?: Function): Promise<AnyObject>;

  /**
   * Returns your open orders
   */
  myOrders(param?: Pagination & {
    /**
     * All:              []
     * Open Orders:      filter: ["has_leaves_qty eq 1"]
     * Filled Orders:    filter: ["has_cum_qty eq 1"]
     * Cancelled Orders: filter: ["has_cxl_qty eq 1"]
     */
    filter?: Array<string>
  }, callback?: Function): Promise<AnyObject>;

  /**
   * Send an order
   */
  sendOrder(params: {
    /**
     * "BUY", "SELL or "1" = BUY, "2" = SELL
     */
    side: OrderSide,

    /**
     * Order type, defaults to LIMIT
     */
    type?: OrderType,

    /**
     * Price in "satoshis". e.g.: 1800 * 1e8
     */
    price?: number,

    /**
     * Stop price
     */
    stopPrice?: number,

    /**
     * Amount to be sent in satoshis. e.g.: 0.5 * 1e8
     */
    amount: number,

    /**
     * Currency pair symbol, check symbols table
     */
    symbol: string,

    /**
     * Optional ClientID
     */
    clientId?: string,

    /**
     * If true, ensures that your order will be added to the order book and not match with a existing order
     */
    postOnly?: boolean,
  }, callback?: Function): Promise<any>;

  /**
   * Cancel an order
   */
  cancelOrder(param?: number | {
    /**
     * Required Order ID to be canceled
     */
    orderId?: number;

    /**
     * You need to pass the clientId (ClOrdID) in order to get a response
     */
    clientId?: string;
  }, callback?: Function): Promise<any>;

  /**
   * Returns a list of your withdraws
   */
  requestWithdrawList(params: DepositWithdrawList, callback?: Function): Promise<any>;

  /**
   * Request a FIAT or bitcoin withdraw
   */
  requestWithdraw(params: {
    /**
     * Withdraw required fields
     */
    data: AnyObject;

    /**
     * Amount of the withdraw
     */
    amount: number;

    /**
     * Method name of withdraw, check with your broker, defaults to bitcoin
     */
    method?: string;

    /**
     * Currency pair symbol to withdraw, defaults to `BTC`
     */
    currency?: string;
  }, callback?: Function): Promise<AnyObject>;

  /**
   * Confirm withdraw to two factor authentication
   */
  confirmWithdraw(params: {
    /**
     * Withdraw ID to confirm
     */
    withdrawId: string;

    /**
     * Confirmation Token sent by email
     */
    confirmationToken?: string;

    /**
     * Second Factor Authentication code generated by authy
     */
    secondFactor?: string;
  }, callback?: Function): Promise<AnyObject>;

  /**
   * Cancel withdraw
   */
  cancelWithdraw(withdrawId: number, callback?: Function): Promise<AnyObject>;

  /**
   * Returns a list of your deposits
   */
  requestDepositList(params: DepositWithdrawList, callback?: Function): Promise<AnyObject>;

  /**
   *  If any arguments was provied, it will generate a bitcoin deposit along with the address.
   */
  requestDeposit(params: {
    /**
      * Value amount to deposit
      */
    value?: number;

    /**
      * Currency pair symbol to withdraw, defaults to `BTC`
      */
    currency?: string;

    /**
      * Method ID to deposit, check `requestDepositMethods`
      */
    depositMethodId?: number;
  }, callback?: Function): Promise<AnyObject>;

  /**
   * Used to check the deposit methods codes to FIAT deposit
   */
  requestDepositMethods(callback?: Function): Promise<AnyObject>;

  /**
   * Request Ledger
   */
  requestLedger(params?: Pagination & {
    /**
     * Currency available on the current broker e.g.: `BTC`, `BRL`, `PKR`, `CLP`.
     * Only one currency is supported on the request.
     */
    currency: string;
  }, callback?: Function): Promise<AnyObject>;
}

export class BlinkTradeRest extends BlinkTradeTrade {
  constructor(props: BlinkTradeRestParams);
  /**
   * Ticker is a summary information about the current status of an exchange.
   */
  ticker(callback?: Function): Promise<AnyObject>;

  /**
    * A list of the last trades executed on an exchange since a chosen date.
    */
  trades(trades?: {
    /**
     * Limit of trades that will be returned. should be a positive integer. Optional; defaults to 1000 trades.
     */
    limit?: number;

    /**
     * TradeID which must be fetched from. Optional;
     */
    since?: number;
  }, callback?: Function): Promise<AnyObject>;

  /**
    * Order book is a list of orders that shows the interest of buyers (bids) and sellers (asks).
    */
  orderbook(callback?: Function): Promise<AnyObject>;
}

export class BlinkTradeWS extends BlinkTradeTrade {
  constructor(props: BlinkTradeWSParams);
  connect: (callback?: Function) => Promise<AnyObject>;
  disconnect: () => any;
  heartbeat: (callback?: Function) => Promise<AnyObject>;
  login: (params: {
    /**
     * Account username or an API Key
     */
    username: string;

    /**
     * Password or an API Password
     */
    password: string;

    /**
     * Optional secondFactor, if the authentication require second factor, you'll receive an error with NeedSecondFactor = true
     */
    secondFactor?: string;

    /**
     * Cancel all orders sent by the session when the websocket disconnects
     */
    cancelOnDisconnect?: boolean;

    /**
     * Optional brokerId
     */
    brokerId?: number;
  }) => Promise<AnyObject>;
  /**
   * Logout session from the server, the connection still connected.
   */
  logout(callback?: Function): Promise<AnyObject>;

  /**
   * Request balance.
   *
   * @Events: `BALANCE`
   */
  balance(clientId?: number, callback?: Function): PromiseEmitter<AnyObject>;

  /**
   * Returns profile information
   */
  profile(callback?: Function): Promise<AnyObject>;

  /**
   * @Events: Any symbol subscribed
   */
  subscribeTicker(symbols: Array<string>, callback?: Function): PromiseEmitter<AnyObject>;

  /**
   * Unsubscribe ticker
   */
  unSubscribeTicker(SecurityStatusReqID: number): number;

  /**
   * Subscribe to orderbook
   */
  subscribeOrderbook(options: MarketDataParams, callback?: Function): PromiseEmitter<AnyObject>;

  /**
   * get orderbook synced
   */
  syncOrderBook(options: MarketDataParams, callback?: Function): Promise<AnyObject>;

  /**
   * Unsubscribe from orderbook
   */
  unSubscribeOrderbook(MDReqID: number): number;

  /**
   * @Events:
   * `EXECUTION_REPORT:NEW`       => Callback when you send a new order
   * `EXECUTION_REPORT:PARTIAL`   => Callback when your order have been partialy executed
   * `EXECUTION_REPORT:EXECUTION` => Callback when an order have been sussefully executed
   * `EXECUTION_REPORT:CANCELED`  => Callback when your order have been canceled
   * `EXECUTION_REPORT:REJECTED`  => Callback when your order have been rejected
   */
  executionReport(callback?: Function): PromiseEmitter<AnyObject>;

  /**
   * A list of the last trades executed in the last 24 hours.
   */
  tradeHistory(params?: Pagination & {
    /**
     * TradeID or Date which executed trades must be fetched from. is in Unix Time date format. Optional; defaults to the date of the first executed trade.
     */
    since?: number;

    /**
     * List os symbols to be returned
     */
    symbols?: Array<string>;
  }, callback?: Function): Promise<AnyObject>;

  /**
   * Callbacks on each deposit update, note that using as promise will only returned once.
   */
  onDepositRefresh(callback?: Function): Promise<AnyObject>

  /**
   * Callbacks on each withdraw update, note that using as promise will only returned once.
   */
  onWithdrawRefresh(callback?: Function): Promise<AnyObject>
}


export type PromiseEmitter<T> = Promise<T> & {
  on: (event: string, listener: Function) => PromiseEmitter<T>;
  onAny: (listener: Function) => PromiseEmitter<T>;
  offAny: (listener: Function) => PromiseEmitter<T>;
  once: (event: string, listener: Function) => PromiseEmitter<T>;
  many: (event: string, times: number, listener: Function) => PromiseEmitter<T>;
  removeListener: (event: string, listener: Function) => PromiseEmitter<T>;
  removeAllListeners: (events: Array<string>) => PromiseEmitter<T>;
};
